## 부품찾기
* 조건
  - 난의도: 1.5
  - 풀이시간: 30분
  - 시간 제한: 1초
  - 메모리 제한: 128MB
* 어느 날 손님이 M개 종류의 부품을 대량으로 구매하겠다며, 당일 날 견적서를 요청했다.
* 동민이는 손님이 문의한 부품 M개 종류를 모두 확인해서 견적서를 작성해야 한다.
* 가게 안에, 손님이 문의한 부품이 모두 있는지 확인하는 프로그램을 작성해보자.

* 예를 들어 가게의 부품이 총 5개일 때, 부품 번호가 다음과 같다고 하자.
  - N = 5
  - [8, 3, 7, 9, 2]
* 손님은 총 3개의 부품이 있는지 확인 요청했는데, 부품 번호는 다음과 같다.
  - M = 3
  - [5, 7, 9]
* 이 때 손님이 요청한 번호의 순서대로 부품을 확인해 부품이 있으면, yes를, 없으면 no를 출력한다. 구분은 공백으로 한다.

* 입력조건:
  - 첫째 줄에 정수 N이 주어진다. (1 <= n <= 1,000,000) -> 부품의 수
  - 둘째 줄에 공백으로 구분하여, N개의 정수가 주어진다. (이때 정수는 1보다 크고, 1,000,000이하 이다.)
  - 셋째 줄에는 정수 M이 주어진다. (1 <= M <= 100,000)
  - 넷째 줄에는 공백으로 구분하여 M개의 정수가 주어진다. (이때 정수는 1보다 크고, 100,000이하 이다.)

* 출력조건:
  - 첫째 줄에 공백으로 구분하여 각 부품이 존재하면 yes를, 없으면 no를 출력한다.

* 입력예시:
  - 5
  - 8 3 7 9 2
  - 3
  - 5 7 9

* 출력예시:
  - no yes yes

**重要**
**試験に出るって**
* 문제 해설 
* 순차탐색으로 이 문제를 풀 경우에는 시간제한을 통과할 수 없다.
* 순차탐색을 하지 않으려면, 이진탐색을 해야하고, 이진탐색을 위해서 일단 정렬이 필요!
* 정렬되었다고 가정하고, 이진탐색을 한다면 시간복잡도는
  * N개의 원소를 가지는 리스트에서 이진탐색을 수행하면 그 시간 복잡도는? O(log N)
    - N이 백만일 경우, log N의 값은? 대략 20
  * M개를 이진탐색으로 찾는다면 시간 복잡도는? O(M log N) 
    - 문제에서 M은 최대 10만이니 이진탐색으로 M개의 원소를 찾기위해 수행하는 연산의 수는 대략 100,000 * 20 = 대략 2,000,000
    - 대략 2백만번으로, 시간제한안에 충분히 해결할 수 있음.
* 위는 N개의 원소가 정렬되었다고 가정했을 때이고, 실제로는 정렬되어 있지 않다.
* 일단은 N개의 원소를 정렬을 해야한다.
  * 정렬의 시간복잡도는 O(N log N), N이 백만이면 1,000,000 * 20 으로, 연산의 수는 대략 20,000,000
* 그래서 정렬하는 시간 + 탐색하는 시간: O(N log N) + O(M log N) = O((M+N) * log N) 
  - (10만 + 100만) * 20 = 대략 22,000,000
* 만약 순차 탐색으로 문제를 풀 경우: M개의 원소 각각에 대해서 O(N)이 걸리게 되니, 10만 * 100만 = 100,000,000,000 (천억)
```python
def binary_search(data, target, start, end) :
# start가 end 이하인 동안
  while start <= end :
    mid = (start+end) // 2 # 또는 int((start+end)/2)
    if data[mid] == target :
      return bid
    elif data[mid] > target :
      end = mid - 1
    else :
      start = mid + 1
  return None

# N(가게의 부품 개수) 입력
n = int(input())
# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력
comps = list(map(int, (input().split)))
# 이진탐색을 위해 부품 번호를 정렬
comps.sort()

# M (손님이 요청한 부품 개수) 입력
m = int(input())
# 손님이 요청한 전체 부품 번호를 공백으로 구분하여 입력
req_comps = list(map(int, input().split()))

# 손님이 요청한 부품 번호를 하나씩 확인
for c in req_comps:
    # 해당 부품이 존재하는지 확인. 이진탐색을 이용
    result = binary_search(comps, c, 0, n-1) # 함수 binary_search()는 c 부품이 comps 리스트에 있으면 그 부품의 인덱스를, 없으면 None을 반환
    if result != None :
        print('yes', end = ' ')
    else :
        print('no', end = ' ')
```

## 계수 정렬 (count sort)
* 계수정렬의 시간 복잡도: O(N+K) -> N은 원소의 수, K는 원소의 최대값
* 계수정렬로 위의 문제를 풀 경우 시간복잡도는? => 정렬을 위해 O(N+K), N = 최대 100만, K = 최대 100만 => 최대 대략 200만번의 연산 필요
  * M개의 원소를 찾는데, 걸리는 시간복잡도는? => 원소 하나당 O(1)이니, M이 10만이면 대략 10만번 연산 필요
  * 총 210만번의 연산 필요

```python
# N(가게의 부품 개수) 입력
n = int(input())
# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력: 부품번호는 1이상 1,000,000 이하의 값
comps = list(map(int, (input().split)))
max_value = max(comps)

# 0부터 max_value 까지의 원소의 수를 저장하기 위한 리스트 선언 및 각 원소 존재 여부를 저장(0 또는 1)
count_list = [0] * (max_value+1) # max_value가 5라면 [0, 0, 0, 0, 0, 0]

#comps 리스트의 부품번호에 해당하는 count_list 인덱스에 1을 기록.
for c in comps : # 5, 2, 3 
  count_list[c] = 1 # [0, 0, 1, 1, 0, 1], 각 부품은 1개만 있을테니 부품이 나올때마다 1을 기록하면 된다.

# 위의 반복문의 시간복잡도는 O(N): N은 원소의 개수 
# 위의 코드까지 실행되면 계수정렬 완료됨.

# M(손님이 확인 요청한 부품 개수)를 입력받기
m = int(input())
# 손님이 요청한 전체 부품 번호를 공백으로 구분하여 입력
req_comps - list(map(int, input().split()))

# 손님이 확인 요청한 부품 번호를 하나씩 확인, 아래 for문의 시간복잡도는 O(K) => K는 원소의 최대값
for c in req_comps:
  if count_list[c] == 1 :
    print('yes', end = ' ')
  else :
    print('no', end = ' ')

```

## 집합자료형을 사용하여 정렬
* set() 메소드를 이용하여, (차집합, 합집합 ...) 등도 표현가능
* 시간복잡도: O(N)
  - 시간복잡도에서는 좋은 성능을 기대하기 어려우나, 구현 난의도는 낮은 편!
```python
# N(가게의 부품 개수) 입력
n = int(input())

# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력: 부품번호는 1이상 1,000,000이하의 값
# 집합: 중복을 허용하지 않고, 순서가 없는 값의 컬렉션
comps_set = set(map(int, input().split()))

# 손님이 확인 요청한 부품 번호를 하나씩 확인, 아래 for문의 시간복잡도는 O(K) => K는 원소의 최대값
for c in req_comps:
  if c in comps_set :
    print('yes', end = ' ')
  else :
    print('no', end = ' ')

```

## 떡볶이 떡 만들기 - 이진탐색
* 동빈이네 떡볶이 떡은 길이가 일저하지 않다.
* 대신 한 봉지 안에 들어가는 떡의 총 길이는 절단기로 잘라서 맞춰준다.
* 절단기에 높이(H)를 지정하면 줄 지어진 떡을 한 번에 절단한다.
* 높이가 H보다 긴 떡은 H 위의 부분이 잘릴 것이고, 낮은 떡은 잘리지 않는다.
* 예를 들어 높이가 19, 14, 10, 17cm인 떡이 나란히 있고 절단기 높이를 15cm로 지정하면 자른 뒤 떡의 높이는 15, 14, 10, 15cm가 될 것이다.
* 잘린 떡의 길이는 차례로 4, 0, 0, 2cm이다
* 손님은 6cm만큼의 길이를 가져간다.
* 손님이 왔을 때 요청한 총 길이가 M일 때 적어도 M만큼의 떡을얻기 위해 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.
  // 가능한 길이에 가깝게 잘라야함

* 입력조건
  - 첫째 줄에 떡의 개수 N과 요청한 떡의 길이 M이 주어진다. ( 1 <= N <= 1,000,000 / 1<= M <= 1,000,000,000)
  - 둘째 줄에 떡의 개별 높이가 주어진다. 떡 높이의 총합은 항상 M 이상이므로, 손님은 필요한 양만큼 떡을 사갈 수 있다.
  - 높이는 10억보다 작거나 같은 양의 정수 또는 0이다.

* 출력조건
  - 적어도 M만큼의 떡을 집에 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.

* 입력 예시
  4 6
  19 15 1 17

* 출력 예시
  15
```python
# 떡의 개수(n)와 요청한 떡의 길이(M)을 입력받기
n, m map(int, input().split())
# 각 떡의 개별 높이 정보를 입력받기
heights_of_ddeok = list(map(int, input().split()))

start = 0
end = max(heights_of_ddeok)
result = 0 # 잘려나간 떡의 총 길이의 합이 M 이상으로 만들 수 있는 절단기의 높이

# 재귀함수 / 반복문(V)
while start <= end :
  mid = (start + end)//2 # 2로 나눈 몫 / 절단기의 높이를 mid로 설정해서 떡을 잘라본다.
  sum = 0
  for hegiht in heights_of_ddeok : # 각 떡에 대해서
    zzaturi = height - mid # 그 떡을 자르고 남은 짜투리의 길이
    if zzaturi > 0 : # 잘려 나간 짜투리가 있으면
      sum += zzaturi # sum에 그 길이를 누적시킨다.
  if sum >= m : # M 이상의 떡을 얻을 수 있다면, 이 절단기의 높이를 result에 저장하고, 절단기의 높이를 높여도 M 이상의 값을 얻을 수 있는지 확인
    result = mid
    start = mid + 1
  else : # M 이상의 떡을 얻을 수 없다는 의미이므로, 절단기의 높이를 낮춰 다시 시도해 본다.
    end = mit - 1

# 정답 출력
print(result)
```
