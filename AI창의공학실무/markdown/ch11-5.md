## 부품찾기
* 조건
  - 난의도: 1.5
  - 풀이시간: 30분
  - 시간 제한: 1초
  - 메모리 제한: 128MB
* 어느 날 손님이 M개 종류의 부품을 대량으로 구매하겠다며, 당일 날 견적서를 요청했다.
* 동민이는 손님이 문의한 부품 M개 종류를 모두 확인해서 견적서를 작성해야 한다.
* 가게 안에, 손님이 문의한 부품이 모두 있는지 확인하는 프로그램을 작성해보자.

* 예를 들어 가게의 부품이 총 5개일 때, 부품 번호가 다음과 같다고 하자.
  - N = 5
  - [8, 3, 7, 9, 2]
* 손님은 총 3개의 부품이 있는지 확인 요청했는데, 부품 번호는 다음과 같다.
  - M = 3
  - [5, 7, 9]
* 이 때 손님이 요청한 번호의 순서대로 부품을 확인해 부품이 있으면, yes를, 없으면 no를 출력한다. 구분은 공백으로 한다.

* 입력조건:
  - 첫째 줄에 정수 N이 주어진다. (1 <= n <= 1,000,000) -> 부품의 수
  - 둘째 줄에 공백으로 구분하여, N개의 정수가 주어진다. (이때 정수는 1보다 크고, 1,000,000이하 이다.)
  - 셋째 줄에는 정수 M이 주어진다. (1 <= M <= 100,000)
  - 넷째 줄에는 공백으로 구분하여 M개의 정수가 주어진다. (이때 정수는 1보다 크고, 100,000이하 이다.)

* 출력조건:
  - 첫째 줄에 공백으로 구분하여 각 부품이 존재하면 yes를, 없으면 no를 출력한다.

* 입력예시:
  - 5
  - 8 3 7 9 2
  - 3
  - 5 7 9

* 출력예시:
  - no yes yes

**重要**
**試験に出るって**
* 문제 해설 
* 순차탐색으로 이 문제를 풀 경우에는 시간제한을 통과할 수 없다.
* 순차탐색을 하지 않으려면, 이진탐색을 해야하고, 이진탐색을 위해서 일단 정렬이 필요!
* 정렬되었다고 가정하고, 이진탐색을 한다면 시간복잡도는
  * N개의 원소를 가지는 리스트에서 이진탐색을 수행하면 그 시간 복잡도는? O(log N)
    - N이 백만일 경우, log N의 값은? 대략 20
  * M개를 이진탐색으로 찾는다면 시간 복잡도는? O(M log N) 
    - 문제에서 M은 최대 10만이니 이진탐색으로 M개의 원소를 찾기위해 수행하는 연산의 수는 대략 100,000 * 20 = 대략 2,000,000
    - 대략 2백만번으로, 시간제한안에 충분히 해결할 수 있음.
* 위는 N개의 원소가 정렬되었다고 가정했을 때이고, 실제로는 정렬되어 있지 않다.
* 일단은 N개의 원소를 정렬을 해야한다.
  * 정렬의 시간복잡도는 O(N log N), N이 백만이면 1,000,000 * 20 으로, 연산의 수는 대략 20,000,000
* 그래서 정렬하는 시간 + 탐색하는 시간: O(N log N) + O(M log N) = O((M+N) * log N) 
  - (10만 + 100만) * 20 = 대략 22,000,000
* 만약 순차 탐색으로 문제를 풀 경우: M개의 원소 각각에 대해서 O(N)이 걸리게 되니, 10만 * 100만 = 100,000,000,000 (천억)
```python
def binary_search(data, target, start, end) :
# start가 end 이하인 동안
  while start <= end :
    mid = (start+end) // 2 # 또는 int((start+end)/2)
    if data[mid] == target :
      return bid
    elif data[mid] > target :
      end = mid - 1
    else :
      start = mid + 1
  return None

# N(가게의 부품 개수) 입력
n = int(input())
# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력
comps = list(map(int, (input().split)))
# 이진탐색을 위해 부품 번호를 정렬
comps.sort()

# M (손님이 요청한 부품 개수) 입력
m = int(input())
# 손님이 요청한 전체 부품 번호를 공백으로 구분하여 입력
req_comps = list(map(int, input().split()))

# 손님이 요청한 부품 번호를 하나씩 확인
for c in req_comps:
    # 해당 부품이 존재하는지 확인. 이진탐색을 이용
    result = binary_search(comps, c, 0, n-1) # 함수 binary_search()는 c 부품이 comps 리스트에 있으면 그 부품의 인덱스를, 없으면 None을 반환
    if result != None :
        print('yes', end = ' ')
    else :
        print('no', end = ' ')
```

## 계수 정렬 (count sort)
* 계수정렬의 시간 복잡도: O(N+K) -> N은 원소의 수, K는 원소의 최대값
* 계수정렬로 위의 문제를 풀 경우 시간복잡도는? => 정렬을 위해 O(N+K), N = 최대 100만, K = 최대 100만 => 최대 대략 200만번의 연산 필요
  * M개의 원소를 찾는데, 걸리는 시간복잡도는? => 원소 하나당 O(1)이니, M이 10만이면 대략 10만번 연산 필요
  * 총 210만번의 연산 필요

```python
# N(가게의 부품 개수) 입력
n = int(input())
# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력: 부품번호는 1이상 1,000,000 이하의 값
comps = list(map(int, (input().split)))
max_value = max(comps)

# 0부터 max_value 까지의 원소의 수를 저장하기 위한 리스트 선언 및 각 원소 존재 여부를 저장(0 또는 1)
count_list = [0] * (max_value+1) # max_value가 5라면 [0, 0, 0, 0, 0, 0]

#comps 리스트의 부품번호에 해당하는 count_list 인덱스에 1을 기록.
for c in comps : # 5, 2, 3 
  count_list[c] = 1 # [0, 0, 1, 1, 0, 1], 각 부품은 1개만 있을테니 부품이 나올때마다 1을 기록하면 된다.

# 위의 반복문의 시간복잡도는 O(N): N은 원소의 개수 
# 위의 코드까지 실행되면 계수정렬 완료됨.

# M(손님이 확인 요청한 부품 개수)를 입력받기
m = int(input())
# 손님이 요청한 전체 부품 번호를 공백으로 구분하여 입력
req_comps - list(map(int, input().split()))

# 손님이 확인 요청한 부품 번호를 하나씩 확인, 아래 for문의 시간복잡도는 O(K) => K는 원소의 최대값
for c in req_comps:
  if count_list[c] == 1 :
    print('yes', end = ' ')
  else :
    print('no', end = ' ')

```
