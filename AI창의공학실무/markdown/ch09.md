## beverage_freeze

## 음료수 얼려 먹기
깊이 우선탐색으로 구현할 수 있음
가로: i / 세로: j
0 0 1 1 0
0 0 0 1 1
1 1 1 1 1
0 0 0 0 0
1. 재귀적으로 상하좌우로 0과 이어진 것을 모두 1로 만듬 -> 바꿀 것이 없을 때까지 (2중 for문)
code:
if g[i][j] == 0 
  g[i][j] = 1
  dfs(i-1, j)
  dfs(i, j+1)
  dfs(i+, j)
  dfs(i, j-1)
return True; // 얼음 한덩어리 당 true 1번 실행

* N * M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다
* 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다
* 이 때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오
* 다음의 4 * 5 얼음 틀 예시에서는 아이스크림이 총 3개 생성된다

  - 4 * 5 예시
00110
00011
11111
00000

* 입력예시 : 15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111

* 출력예시 - 8

```python
# n, m을 공백으로 구분하여 입력받기
n, m map(input().split())

# 2차원 리스트의 맵 정보 입력받기
graph = []
for i in range(n) :
  graph.append(list(map(int, input()))) # [[0,0,1,1,....], [1,1,1,....], ..., [...] ]

# 얼음틀 정보가 입력되었으니, 각 행의 각 열을 방문하면서 아래를 수행하는 함수를 작성한다
# 1. graph[i][j] == 0이면 그 값을 1로 변경하고
#  1-2. graph[i][j]를 기준으로 상, 하, 좌, 우를 재귀적으로 방문하며 1을 수행
#  1-3. True를 반환
# 2. graph[i][j] 가 0이 아니면 False를 반환

def dfs(row, col) :
  # 재귀함수이기 때문에 탈출조건을 먼저 조사해야 한다.
  # 주어진 row, col이 n * m의 범위를 벗어났는지 검사
  # 0 <= roew < n, 0 <= col < m
  if  row < 0 or row >= n or col < 0 or col >= m) :
    return False

  # 현재 노드를 방문하지 않았다면, 즉, graph[row][col] == 0이면
  if graph[row][col] == 0 :
     graph[row][col] = 1 # 방문처리
     # 상, 하, 좌, 우를 재귀적으로 방문
     dfs(row-1, col)
     dfs(row+1, col)
     dfs(row, col-1)
     dfs(row, col+1)
     # True를 반환
     return True
  return False
# 각 행에 대해 그 행의 각 열에 대해서
# dfs(row, col) 호출한 결과가 True이면 count를 1 증가
for i in range(n) :
  for j in range(m) :
    if dfs(i, j) == True :
      count += 1

# count의 값을 출력: 이 값이 아이스크림 덩어리의 갯수
print(count)
```
